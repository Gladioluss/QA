<details> 
<summary>Какие есть виды тестирования?</summary> 
<p>Могу перечислить по группам.  </p>
<p>По уровню: модульное, интеграционное, системное, приёмочное.  </p>
<p>По целям: функциональное, нефункциональное.  </p>
<p>По подходу: позитивное, негативное, регрессионное, smoke-тестирование, exploratory, ad-hoc, тестирование безопасности, нагрузки, совместимости, юзабилити, локализации, инсталляционное и восстановление после отказа.</p>
<p></p>
<p>Вы тестируете одну задачу без подключения к другим сервисам — это модульное. </p> 
<p>Проверяете, как ваша система передаёт данные по API в другую систему— это интеграционное.  </p>
<p>Проходите полный путь от выбора до оплаты — это системное.  </p>
<p>Просто убедились, что всё запускается — это smoke.  </p>
<p>Проверили, что баг исправлен — это ретест.  </p>
<p>Прогнали всё перед релизом — это регресс. </p> 
<p>Вводите корректные данные — позитивное. </p><p>Пробуете ввести фигню — негативное.  </p>
<p>Тестируете внешний вид, поведение, переключение языков — нефункциональное и локализация.  </p>
<p>Кликаете по системе без требований, на здравом смысле — исследовательское.</p>
<p>— если есть требования и вы их читаете — это статическое тестирование  </p>
<p>— если просто выполняете проверку руками — это динамическое, чаще всего функциональное  </p>
<p>— если составляете чек-листы или тест-кейсы — это основа для smoke или регресса в будущем  </p>
<p>— если сначала изучаете продукт, чтобы сделать задание — это исследовательское  </p>
<p>— если в Руспасе меняете язык и валюту — это уже локализация  </p>
<p>— если в тест-кейсах или примерах используете как правильные, так и ошибочные данные — это и есть позитивное и негативное тестирование</p>
</details>
<details> 
<summary>Какие виды тестирования применяли на практике?</summary> 
<p>**Функциональное тестирование**<p>
<p>— Проверяли, соответствует ли функциональность требованиям. Это основа любой задачи.</p>
<p>**Нефункциональное тестирование**  </p>
<p>— UI/UX, удобство использования, визуальные проверки, отклики системы. Если говорили «всё криво», «кнопка непонятная» — это тоже сюда.</p>
<p>Позитивное и негативное </p>
<p>— Вводили корректные данные — позитивные сценарии.  </p>
<p>— Проверяли, как система ведёт себя с некорректными — негативные.</p>
<p>**Модульное (в тестировании, не в разработке)**</p>
<p>— Сначала поясните, что вы понимаете под этим: в системе мы выделяли отдельный функциональный модуль или сервис и проверяли его изолированно, без участия остальных компонентов.</p>
<p>**Интеграционное**  </p>
<p>— Сначала поясните, что вы под этим понимаете: мы проверяли, как взаимодействуют между собой разные части системы — как данные или запросы передаются от одного модуля к другому и корректно ли они обрабатываются.</p>
<p>**Интеграция бывает двух типов:**</p>
<p>- Внутренняя — когда взаимодействие происходит внутри вашего приложения, например, между микросервисами, или между фронтом и бэком. Также сюда можно отнести ситуации, когда ваша система обращается к другой системе внутри компании, но за неё отвечает другая команда.</p>
<p>- Внешняя — когда ваша система взаимодействует с внешними продуктами или сервисами, которые находятся вне вашей компании </p>
<p>**Системное**  </p>
<p>— Это когда вы тестируете работу всей системы целиком — от начала до конца. Часто такое называют E2E. То есть вы не просто проверяете один экран или один сервис, а проходите полный путь, как это делает конечный пользователь.</p>
<p>**Приёмочное**  </p>
<p>— Упоминайте, только если действительно была демо-презентация, релизная проверка, показ продукта команде или заказчику.  </p>
<p>**Smoke**  </p>
<p>— Минимальный набор проверок, чтобы понять: система встала, работает, можно дальше проверять. Это то, что обычно делают сразу после сборки.</p>
<p>**Регрессионное**  </p>
<p>— Повторная проверка всей системы, чтобы убедиться: после изменений ничего не сломалось. Это максимальное покрытие, особенно перед релизом.</p>
<p>**Расширенное тестирование**</p>
<p>— Это имеет смысл упомянуть, если у вас не было чётких требований или структуры. То есть вы сами решали, как и что проверять, ориентируясь на продукт.</p>
<p>**Статическое и динамическое**</p>
<p>— Статическое: смотрели требования, искали ошибки на этапе документации.  </p>
<p>— Динамическое: работали с продуктом, выполняли проверки вручную.</p>
<p>**Объёмное тестирование**</p>
<p>— Например, загружали файлы, проверяли работу с большими данными.</p>
<p>**Инсталляционное**</p>
<p>— Если вы проверяли установку, обновление, удаление приложения.</p>
<p>Тестирование локализации  </p>
<p>— Упоминайте, если работали с разными языками: переключали язык, проверяли, что всё на месте, влезает в кнопки, нет перевода с ошибками.</p>
</details>
<details> 
<summary>А вы делали санити-тестирование?</summary> 
<p>- Если описывают поверхностную проверку после изменений:  </p>
<p>— Да, мы такое делали, но у нас это называлось просто smoke или "проверка после обновления функционала".</p>
<p>- Если говорят о частичном прогоне регресса:  </p>
<p>— Да, но у нас это называли "частичная регрессия" или просто ограниченная проверка по критичным сценариям.</p>
<p>- Если определение вообще плавает:  </p>
<p>— Понял, у нас это так не называли, но по смыслу мы это делали. Обычно это попадало либо в smoke, либо просто в короткую проверку после обновлений.</p>
</details>
<details> 
<summary>Расскажите про пирамиду тестирования</summary> 
<p>— Пирамида показывает, как должны быть распределены тесты, чтобы продукт можно было проверять быстро, дёшево и эффективно.  </p>
<p>Внизу — модульные тесты, их больше всего. Они быстрые, дешёвые, изолированные, и позволяют находить ошибки на раннем этапе.  </p>
<p>Выше — интеграционные тесты, их меньше, потому что они сложнее, зависят от окружения, требуют связей.  </p>
<p>На вершине — UI или E2E-тесты. Они дорогие, медленные, нестабильные, и их должно быть мало, только для проверки самых важных пользовательских сценариев.</p>
</details>
<details> 
<summary>Почему это эффективна именно такая пирамида?</summary> 
<p>Потому что дешёвые тесты покрывают больше, и чем выше по пирамиде — тем дороже ошибка и медленнее обратная связь. Баланс даёт и скорость, и стабильность.</p>
</details>
<details> 
<summary>Почему модульных больше всего в пирамиде тестирования?</summary> 
<p>Потому что они покрывают всю бизнес-логику на раннем этапе. Ошибки, найденные тут, чинятся быстро и без лишнего шума.</p>
</details>
<details> 
<summary>Почему UI-тестов мало в пирамиде тестирования?</summary> 
<p>Потому что они медленные, зависят от фронта, окружения, багов в других системах. Они нужны, но точечно: на критичный сценарий — оформить заказ, провести платёж, создать документ.</p>
</details>
<details> 
<summary>Чем отличается позитивное от негативного?</summary> 
<p>— Позитивное — проверяем, что система принимает правильные данные.  </p>
<p>Негативное — проверяем, что система правильно реагирует на неправильные данные. </p> 
<p>— Например: ввёл корректный номер телефона — это позитивный. Ввёл буквы вместо цифр — негативный.</p>
</details>
<details> 
<summary>Чем отличается smoke от регрессии?</summary> 
<p>  
— Smoke — это минимальный набор проверок, чтобы убедиться, что всё вообще запускается и работает.  </p>
<p> Регрессия — это максимальный набор проверок, чтобы убедиться, что изменения ничего не сломали.</p>
</details>
<details> 
<summary>Что такое тестирование на основе требований и как оно влияет на процесс тестирования?</summary> 
<p>**Тестирование на основе требований** — это подход, при котором тесты разрабатываются на основе требований к системе. Это помогает убедиться, что приложение соответствует ожиданиям пользователей.</p>
</details>
<details> 
<summary>Чем отличается регрессия от ретеста</summary> 
<p>Ретест  </p>
<p>— Это повторная проверка конкретного бага или функционала, который исправляли.</p>  
<p>Например, вы заводили баг на то, что нельзя удалить заказ. Разработчик починил. Вы снова запускаете тот же сценарий — это ретест.</p>
<p>Регрессия  </p>
<p>— Это проверка других участков системы, чтобы убедиться, что после правки ничего не сломалось в другом месте.  </p>
<p>Например, после фикса удаления заказа вы пошли и проверили создание, редактирование, отображение в списке — это уже регрессия.</p>
<p>— Обычно сначала делают ретест, а потом — регрессию, особенно если баг был в критичном месте.</p>
</details>
<details> 
<summary>Что такое пирамида тестирования и какие уровни в нее входят?</summary> 
<p>**Пирамида тестирования** — это концепция, которая иллюстрирует разные уровни тестирования и их соотношение. Обычно в нее входят три уровня:</p>
<p>- Модульные тесты (на самом низу)</p>
<p>- Интеграционные тесты (в середине)</p>
<p>- Системные тесты (на вершине)</p>
</details>
<details> 
<summary>Почему пирамида тестирования пирамида? Не квадрат, круг?</summary> 
<p>Это связано с тем, что модульных тестов должно быть больше, чем интеграционных и системных. Модульные тесты более простые и быстрые, их легче писать и поддерживать.</p>
</details>
<details> 
<summary>Какие тесты следует автоматизировать в первую очередь и почему?</summary> 
<p>**Автоматизация тестов**: в первую очередь следует автоматизировать те тесты, которые выполняются часто и требуют много времени при ручном тестировании, например, регрессионные тесты.</p>
</details>
<details> 
<summary>Какую роль в пирамиде тестирования играют модульные тесты? Почему они составляют основу пирамиды?</summary> 
<p>**Роль модульных тестов** в пирамиде тестирования заключается в том, что они проверяют отдельные компоненты системы. Они составляют основу пирамиды, потому что обеспечивают быструю обратную связь и помогают выявить ошибки на ранних этапах разработки</p>
</details>
<details> 
<summary>Что такое тестирование на основе риска?</summary> 
<p>**Тестирование на основе риска** — это подход, при котором тесты приоритизируются в зависимости от потенциального риска, связанного с функциональностью. Это помогает сосредоточиться на наиболее критичных частях приложения</p>
</details>
<details> 
<summary>Порядок тестирований на проекте</summary> 
<p>1.Вводная часть</p>
<p>Всё начинается с замысла: мы хотим решить какую-то задачу, закрыть потребность, упростить людям жизнь или автоматизировать процессы.</p>
<p>2.Стадия идеи и MVP</p>
<p>Параллельно проектируется интерфейс. Делают макеты. И уже здесь можно проводить UI/UX тестирование — понятна ли структура, логична ли навигация, видны ли кнопки, доступны ли поля на экранах. Всё это проверяется ещё до кода.</p>
<p>3.Первая реализация и ручные проверки</p>
<p>Появился первый код — значит начинается динамическое тестирование. Всё, что связано с выполнением программы: что-то запускается, что-то возвращается. И вместе с этим — функциональное тестирование. Мы проверяем: система делает то, что описано в требованиях или нет?
Все базовые проверки на этом этапе — это позитивное тестирование.Но и негативные проверки уместны.
Если мы говорим про веб — здесь в игру вступают разные устройства, браузеры, экраны. Если говорим про приложение — обязательно инсталляционное тестирование: установка, удаление, обновление, конфликт версий. Всё это нужно вручную проверить.</p>
<p>4.Временные отсечки и исследовательские подходы</p>
<p>- Исследовательское тестирование — знакомимся с системой, ищем закономерности и странности.
- Ad-hoc — просто запускаем и смотрим, как себя ведёт.
- Манки-тестирование — нажимаем хаотично, пробуем нестандартные действия.</p>
<p>5.Переход к структуре: smoke, регресс и re-test</p>
<p>Выделяем минимум проверок, которые всегда должны проходить — это smoke-тестирование. Проверка базовой работоспособности.
При тестировании функционала или smoke-набора могут обнаружиться дефекты. В таком случае заводится баг-репорт, а после его исправления проводится ретест — точечная проверка, что конкретный баг действительно устранён. Только баг, только конкретный сценарий. Без расширений и дополнительных проверок.
А для полной уверенности запускаем регрессионное тестирование. Это все ключевые сценарии, которые не должны ломаться от изменений. Мы постепенно переходим от хаотичного к системному подходу.</p>
<p>6.Ящики: чёрный, белый, серый</p>
<p>Если мы не смотрим в код — это чёрный ящик. Просто ввод-вывод. Если имеем доступ и понимаем внутреннюю логику — белый ящик. Если доступ есть частично или мы комбинируем подходы — серый ящик. Применимо в любой момент проекта.</p>
<p>7.Архитектура и модули</p>
 <p>Здесь пригодится интеграционное тестирование: как наши модули взаимодействуют между собой.
Когда два модуля объединены, можно говорить уже о системном тестировании — мы проверяем работу всей системы целиком. А когда демонстрируем результат заказчику, показываем, реализовано ли то, что он ожидал — это уже приёмочное тестирование.</p>
<p>8.Ручное и автоматизированное тестирование</p>
<p>9.Нагрузочное и безопасность</p>
<p>- Тестирование производительности — справляется ли система с нужной скоростью.
- Стрессовое тестирование — что будет, если нагрузка превысит ожидаемую.
  По части защиты — тестирование безопасности. В нашем случае используются базовые защиты: HTTPS, ограничение прав, защита от SQL-инъекций.</p>
<p>10.Объём, анализ и выводы</p>
<p>Когда MVP создан — начинается анализ. Проводятся A/B тесты, собирается статистика, бизнес оценивает востребованность приложения.</p>
<p>11.Финальный аккорд</p>

</details>









