<details> 
<summary>Какие есть виды тестирования?</summary> 
<p>Функциональное тестирование</p>
<p> Это процесс проверки, работает ли программа так, как задумано в требованиях. Оно сосредоточено на проверке того, что должна делать система, а не на том, как она устроена внутри.</p>
<p></p>
<p>Нефункциональное тестирование</p>
<p>Это процесс проверки характеристик системы, которые не связаны напрямую с её функциями, а касаются того, как эти функции выполняются. Оно помогает убедиться, что система работает быстро, стабильно, удобно, надёжно и безопасно.</p>
<p></p>
<p>UI/Ux тестирование</p>
<p>Это процесс проверки удобства использования (UX — user experience) и правильности реализации пользовательского интерфейса (UI — user interface). Оно помогает понять, насколько комфортно пользователю взаимодействовать с продуктом и насколько корректно реализованы дизайн и логика расположения элементов.</p>
<p></p>
<p>Тестирование производительности</p>
<p>Это проверка того, как система ведёт себя в условиях нагрузки. </p>
<p>**Нагрузочное тестирование:** Проверка, как система работает при обычной или немного увеличенной нагрузке.    
- **Стрессовое тестирование:** Проверка поведения системы в условиях экстремальной нагрузки, превышающей норму.
- **Тестирование стабильности:** Проверка способности системы работать без сбоев в течение длительного времени. 
- **Тестирование масштабируемости:** Проверка, как система справляется с увеличением ресурсов.</p>
<p></p>
<p>Тестирование отказа и восстановления</p>
<p>Это проверка, как система ведёт себя при сбоях и насколько быстро и корректно возвращается в рабочее состояние. Оно показывает, как система реагирует на сбой и что происходит дальше — продолжается ли работа, теряются ли данные, требуется ли перезапуск вручную.</p>
<p></p>
<p>Тестирование безопасности</p>
<p>Проверяет, есть ли уязвимости, через которые злоумышленник может получить доступ к данным, обойти авторизацию или нарушить работу системы.</p>
<p></p>
<p>Тестирование локализации</p>
<p>Это проверка, насколько продукт адаптирован для пользователей из разных стран и регионов. Это не только про перевод текста, но и про корректное отображение дат, времени, валют, единиц измерения, шрифтов и направления элементов интерфейса.</p>
<p></p>
<p>Инсталяционное тестирование</p>
<p>Это проверка того, как программа устанавливается, обновляется и удаляется. Задача — убедиться, что установка проходит без ошибок, продукт запускается сразу после установки, а после удаления не остаётся мусора в системе.</p>
<p></p>
<p>Тестирование объема данных</p>
<p>Это не отдельный этап, а часть повседневной работы. Оно начинается там, где привычные сценарии вдруг перестают работать так же быстро и стабильно, как раньше. Система накапливает данные, и в какой-то момент это начинает её перегружать.</p>
<p></p>
<p></p>
<p>*По позитивности (By Posititvity)*</p>
<p></p>
<p>Позитивное тестирование</p>
<p>Это не отдельный вид тестирования, а основа любого другого. С него начинается любая проверка: если базовый сценарий не работает, все остальные тесты — бесполезны.</p>
<p></p>
<p>Негативное тестирование</p>
<p>Это процесс проверки системы в условиях, когда данные или действия пользователя выходят за рамки допустимого. Оно помогает убедиться, что система правильно обрабатывает ошибки, остаётся стабильной и не даёт сбоев при некорректных действиях.</p>
<p></p>
<p></p>
<p>*По степени детализации (By Level of Detail)*</p>
<p></p>
<p>Модульное тестирование</p>
<p>Это процесс проверки отдельных частей системы (модулей) в изоляции от других компонентов. Этот уровень тестирования позволяет убедиться, что конкретные модули системы, например, модуль оплаты или избранного, выполняют свою функцию корректно и соответствуют требованиям. Модульное тестирование помогает выявить ошибки в маленьких частях системы до того, как они могут повлиять на интеграцию с другими компонентами.  </p>
<p></p>
<p>Интергационное тестирование</p>
<p>Это проверка связи между модулями и системами. Оно не про то, работает ли кнопка, а про то, как данные проходят через всю цепочку: от одного компонента к другому. Проблемы чаще всего всплывают не внутри модулей, а на стыках. Проверка строится на понимании контрактов, доступности логов, готовности модуля-партнёра и умении отследить, где именно что-то пошло не так. Без этого баги теряются, а система остаётся формально рабочей, но не связной.</p>
<p></p>
<p>Системное тестирование</p>
<p>Это проверка всей системы в целом, включая модули, интерфейсы, интеграции и бизнес-логику. Оно проводится после модульного и интеграционного тестирования и позволяет убедиться, что всё работает как единое целое и соответствует требованиям.</p>
<p></p>
<p>Приемочное тестирование</p>
<p>Это заключительная проверка системы с точки зрения заказчика. Оно проводится для того, чтобы убедиться, что продукт соответствует согласованным требованиям и может быть принят в эксплуатацию. Этот уровень тестирования направлен на проверку бизнес-логики, пользовательских сценариев и ключевых функций — без акцента на технические детали.</p>
<p></p>
<p>Сквозное тестирование</p>
<p>Перед началом работы изучаются требования: это может быть формальный документ, тикет (задача) в трекере (задачнике, например: Jira), макет или устное описание на встрече. Даже если всё размыто, тестировщик должен собрать картину — через обсуждение, аналогии или анализ уже реализованного.</p>
<p></p>
<p></p>
<p>*По степени готовности (By Readiness Level)*</p>
<p></p>
<p>Альфа- тестирование</p>
<p>Это проверка сырого продукта на раннем этапе, когда система ещё не готова к полноценному использованию, но ключевая идея уже реализована. На этом уровне важно понять, работает ли базовая концепция: выполняется ли главная задача, ради которой продукт создавался.</p>
<p></p>
<p>Бета-тестирование</p>
<p>Это стадия проверки продукта, когда система уже реализует весь заявленный функционал, но ещё может содержать недочёты перед релизом. Это не этап поиска идеи, а проверка готового решения в условиях, приближённых к реальной эксплуатации.</p>
<p></p>
<p>MVP</p>
<p> Это рабочая версия системы, в которой реализован только базовый набор функций, необходимых для решения основной задачи пользователя. Всё остальное — отложено. Это не черновик и не недоделка, а минимальный, но действующий продукт, созданный для проверки гипотезы на практике.
</p>
<p></p>
<p></p>
<p>*По степени автоматизации (By Automation Level)*</p>
<p></p>
<p>Ручное тестирование</p>
<p>Это процесс, при котором систему проверяют вручную, без использования скриптов или вспомогательных инструментов. Все действия выполняются руками, результаты сравниваются с ожидаемыми, отклонения фиксируются.</p>
<p></p>
<p>Автоматизированное тестирование</p>
<p>Это процесс, при котором система проверяется с помощью заранее написанных скриптов. Эти скрипты запускаются автоматически и проверяют работу функций без ручного участия.</p>
<p></p>
<p>--------------------------</p>
<p>Смоук тестирование</p>
<p>Это минимальный набор проверок, выполняемый после сборки системы. Проверяются только базовые действия, которые показывают, что система запускается и выполняет ключевые функции без критических ошибок.
</p>
<p></p>
<p>Регрессионное тестирование</p>
<p>Это проверка, что изменения в системе не сломали уже работающий функционал. Выполняются повторные проверки, чтобы убедиться: всё, что раньше работало, продолжает работать так же.</p>
<p></p>
<p>Санти</p>
<p>Это термин, который по-разному трактуется в разных источниках. Одни говорят, что это узкая проверка конкретной части системы. Другие считают, что это быстрая проверка конкретного исправления. Всё это не имеет единого стандарта.</p>
<p></p>
<p>Повторное тестирование</p>
<p>Это точечная проверка исправленной ошибки. Тестировщик возвращается к сценарию, где ранее был баг, и проверяет, воспроизводится ли он после исправления.</p>
<p></p>
<p>A/B тестирование</p>
<p>Это сравнение двух версий одной функциональности с минимальными отличиями. Изменения могут быть визуальными, текстовыми или логическими. Каждая группа пользователей видит свой вариант, и поведение отслеживается отдельно.</p>
<p></p>
<p>Исследовательское тестирование</p>
<p>Это проверка системы в условиях, когда нет чёткого понимания, что именно и как проверять. Тестировщик сам изучает продукт, чтобы понять его поведение, выявить проблемы, пробелы в логике или интерфейсе.</p>
<p></p>
<p>Тестирование критического пути</p>
<p>Это проверка ключевого сценария, без которого продукт теряет смысл. Это минимальный набор шагов, который должен работать в любом состоянии системы.</p>
<p></p>
<p>Расширенное тестирование</p>
<p>Это проверка не только основного функционала, но и всех связанных областей, которые могут быть затронуты изменениями. Это подход с более широким охватом, когда важно проверить не только то, что напрямую поменялось, но и то, что может повлиять на работу всей системы.</p>
<p></p>
<p>Случайное тестирование</p>
<p>Это взаимодействие с системой без заранее составленных сценариев и логики. Тестировщик выполняет хаотичные действия: нажимает, вводит случайные значения, переключает экраны, нарушает обычный порядок использования.
</p>
<p></p>
<p>Свободное тестирование</p>
<p>Это проверка системы без заранее составленных сценариев, тест-кейсов или чек-листов. Действия строятся на опыте, знании продукта и интуиции.</p>
<p></p>
<p></p>
<p>*По запуску кода (By Code Execution)*</p>
<p></p>
<p>Статистическое тестирование</p>
<p>Это анализ артефактов разработки без запуска системы. Проверяются требования, код, архитектура, документация и другие материалы, чтобы найти ошибки ещё до выполнения программы.</p>
<p></p>
<p>Динамическое тестирование</p>
<p>Это проверка работы системы в процессе её выполнения. В этом типе тестирования оценивается фактическое поведение программы: как она запускается, обрабатывает ввод, реагирует на действия и выполняет заданные функции. Всё происходит в реальном времени, при активной работе системы.</p>
<p></p>
<p></p>
<p></p>
</details>
<details> 
<summary>Какие виды тестирования применяли на практике?</summary> 
<p>**Функциональное тестирование**<p>
<p>— Проверяли, соответствует ли функциональность требованиям. Это основа любой задачи.</p>
<p>**Нефункциональное тестирование**  </p>
<p>— UI/UX, удобство использования, визуальные проверки, отклики системы. Если говорили «всё криво», «кнопка непонятная» — это тоже сюда.</p>
<p>Позитивное и негативное </p>
<p>— Вводили корректные данные — позитивные сценарии.  </p>
<p>— Проверяли, как система ведёт себя с некорректными — негативные.</p>
<p>**Модульное (в тестировании, не в разработке)**</p>
<p>— Сначала поясните, что вы понимаете под этим: в системе мы выделяли отдельный функциональный модуль или сервис и проверяли его изолированно, без участия остальных компонентов.</p>
<p>**Интеграционное**  </p>
<p>— Сначала поясните, что вы под этим понимаете: мы проверяли, как взаимодействуют между собой разные части системы — как данные или запросы передаются от одного модуля к другому и корректно ли они обрабатываются.</p>
<p>**Интеграция бывает двух типов:**</p>
<p>- Внутренняя — когда взаимодействие происходит внутри вашего приложения, например, между микросервисами, или между фронтом и бэком. Также сюда можно отнести ситуации, когда ваша система обращается к другой системе внутри компании, но за неё отвечает другая команда.</p>
<p>- Внешняя — когда ваша система взаимодействует с внешними продуктами или сервисами, которые находятся вне вашей компании </p>
<p>**Системное**  </p>
<p>— Это когда вы тестируете работу всей системы целиком — от начала до конца. Часто такое называют E2E. То есть вы не просто проверяете один экран или один сервис, а проходите полный путь, как это делает конечный пользователь.</p>
<p>**Приёмочное**  </p>
<p>— Упоминайте, только если действительно была демо-презентация, релизная проверка, показ продукта команде или заказчику.  </p>
<p>**Smoke**  </p>
<p>— Минимальный набор проверок, чтобы понять: система встала, работает, можно дальше проверять. Это то, что обычно делают сразу после сборки.</p>
<p>**Регрессионное**  </p>
<p>— Повторная проверка всей системы, чтобы убедиться: после изменений ничего не сломалось. Это максимальное покрытие, особенно перед релизом.</p>
<p>**Расширенное тестирование**</p>
<p>— Это имеет смысл упомянуть, если у вас не было чётких требований или структуры. То есть вы сами решали, как и что проверять, ориентируясь на продукт.</p>
<p>**Статическое и динамическое**</p>
<p>— Статическое: смотрели требования, искали ошибки на этапе документации.  </p>
<p>— Динамическое: работали с продуктом, выполняли проверки вручную.</p>
<p>**Объёмное тестирование**</p>
<p>— Например, загружали файлы, проверяли работу с большими данными.</p>
<p>**Инсталляционное**</p>
<p>— Если вы проверяли установку, обновление, удаление приложения.</p>
<p>Тестирование локализации  </p>
<p>— Упоминайте, если работали с разными языками: переключали язык, проверяли, что всё на месте, влезает в кнопки, нет перевода с ошибками.</p>
</details>
<details> 
<summary>А вы делали санити-тестирование?</summary> 
<p>- Если описывают поверхностную проверку после изменений:  </p>
<p>— Да, мы такое делали, но у нас это называлось просто smoke или "проверка после обновления функционала".</p>
<p>- Если говорят о частичном прогоне регресса:  </p>
<p>— Да, но у нас это называли "частичная регрессия" или просто ограниченная проверка по критичным сценариям.</p>
<p>- Если определение вообще плавает:  </p>
<p>— Понял, у нас это так не называли, но по смыслу мы это делали. Обычно это попадало либо в smoke, либо просто в короткую проверку после обновлений.</p>
</details>
<details> 
<summary>Расскажите про пирамиду тестирования</summary> 
<p>— Пирамида показывает, как должны быть распределены тесты, чтобы продукт можно было проверять быстро, дёшево и эффективно.  </p>
<p>Внизу — модульные тесты, их больше всего. Они быстрые, дешёвые, изолированные, и позволяют находить ошибки на раннем этапе.  </p>
<p>Выше — интеграционные тесты, их меньше, потому что они сложнее, зависят от окружения, требуют связей.  </p>
<p>На вершине — UI или E2E-тесты. Они дорогие, медленные, нестабильные, и их должно быть мало, только для проверки самых важных пользовательских сценариев.</p>
</details>
<details> 
<summary>Почему это эффективна именно такая пирамида?</summary> 
<p>Потому что дешёвые тесты покрывают больше, и чем выше по пирамиде — тем дороже ошибка и медленнее обратная связь. Баланс даёт и скорость, и стабильность.</p>
</details>
<details> 
<summary>Почему модульных больше всего в пирамиде тестирования?</summary> 
<p>Потому что они покрывают всю бизнес-логику на раннем этапе. Ошибки, найденные тут, чинятся быстро и без лишнего шума.</p>
</details>
<details> 
<summary>Почему UI-тестов мало в пирамиде тестирования?</summary> 
<p>Потому что они медленные, зависят от фронта, окружения, багов в других системах. Они нужны, но точечно: на критичный сценарий — оформить заказ, провести платёж, создать документ.</p>
</details>
<details> 
<summary>Чем отличается позитивное от негативного?</summary> 
<p>— Позитивное — проверяем, что система принимает правильные данные.  </p>
<p>Негативное — проверяем, что система правильно реагирует на неправильные данные. </p> 
<p>— Например: ввёл корректный номер телефона — это позитивный. Ввёл буквы вместо цифр — негативный.</p>
</details>
<details> 
<summary>Чем отличается smoke от регрессии?</summary> 
<p>  
— Smoke — это минимальный набор проверок, чтобы убедиться, что всё вообще запускается и работает.  </p>
<p> Регрессия — это максимальный набор проверок, чтобы убедиться, что изменения ничего не сломали.</p>
</details>
<details> 
<summary>Что такое тестирование на основе требований и как оно влияет на процесс тестирования?</summary> 
<p>**Тестирование на основе требований** — это подход, при котором тесты разрабатываются на основе требований к системе. Это помогает убедиться, что приложение соответствует ожиданиям пользователей.</p>
</details>
<details> 
<summary>Чем отличается регрессия от ретеста</summary> 
<p>Ретест  </p>
<p>— Это повторная проверка конкретного бага или функционала, который исправляли.</p>  
<p>Например, вы заводили баг на то, что нельзя удалить заказ. Разработчик починил. Вы снова запускаете тот же сценарий — это ретест.</p>
<p>Регрессия  </p>
<p>— Это проверка других участков системы, чтобы убедиться, что после правки ничего не сломалось в другом месте.  </p>
<p>Например, после фикса удаления заказа вы пошли и проверили создание, редактирование, отображение в списке — это уже регрессия.</p>
<p>— Обычно сначала делают ретест, а потом — регрессию, особенно если баг был в критичном месте.</p>
</details>
<details> 
<summary>Что такое пирамида тестирования и какие уровни в нее входят?</summary> 
<p>**Пирамида тестирования** — это концепция, которая иллюстрирует разные уровни тестирования и их соотношение. Обычно в нее входят три уровня:</p>
<p>- Модульные тесты (на самом низу)</p>
<p>- Интеграционные тесты (в середине)</p>
<p>- Системные тесты (на вершине)</p>
</details>
<details> 
<summary>Почему пирамида тестирования пирамида? Не квадрат, круг?</summary> 
<p>Это связано с тем, что модульных тестов должно быть больше, чем интеграционных и системных. Модульные тесты более простые и быстрые, их легче писать и поддерживать.</p>
</details>
<details> 
<summary>Какие тесты следует автоматизировать в первую очередь и почему?</summary> 
<p>**Автоматизация тестов**: в первую очередь следует автоматизировать те тесты, которые выполняются часто и требуют много времени при ручном тестировании, например, регрессионные тесты.</p>
</details>
<details> 
<summary>Какую роль в пирамиде тестирования играют модульные тесты? Почему они составляют основу пирамиды?</summary> 
<p>**Роль модульных тестов** в пирамиде тестирования заключается в том, что они проверяют отдельные компоненты системы. Они составляют основу пирамиды, потому что обеспечивают быструю обратную связь и помогают выявить ошибки на ранних этапах разработки</p>
</details>
<details> 
<summary>Что такое тестирование на основе риска?</summary> 
<p>**Тестирование на основе риска** — это подход, при котором тесты приоритизируются в зависимости от потенциального риска, связанного с функциональностью. Это помогает сосредоточиться на наиболее критичных частях приложения</p>
</details>
<details> 
<summary>Порядок тестирований на проекте</summary> 
<p>1.Вводная часть</p>
<p>Всё начинается с замысла: мы хотим решить какую-то задачу, закрыть потребность, упростить людям жизнь или автоматизировать процессы.</p>
<p>2.Стадия идеи и MVP</p>
<p>Параллельно проектируется интерфейс. Делают макеты. И уже здесь можно проводить UI/UX тестирование — понятна ли структура, логична ли навигация, видны ли кнопки, доступны ли поля на экранах. Всё это проверяется ещё до кода.</p>
<p>3.Первая реализация и ручные проверки</p>
<p>Появился первый код — значит начинается динамическое тестирование. Всё, что связано с выполнением программы: что-то запускается, что-то возвращается. И вместе с этим — функциональное тестирование. Мы проверяем: система делает то, что описано в требованиях или нет?
Все базовые проверки на этом этапе — это позитивное тестирование.Но и негативные проверки уместны.
Если мы говорим про веб — здесь в игру вступают разные устройства, браузеры, экраны. Если говорим про приложение — обязательно инсталляционное тестирование: установка, удаление, обновление, конфликт версий. Всё это нужно вручную проверить.</p>
<p>4.Временные отсечки и исследовательские подходы</p>
<p>- Исследовательское тестирование — знакомимся с системой, ищем закономерности и странности.
- Ad-hoc — просто запускаем и смотрим, как себя ведёт.
- Манки-тестирование — нажимаем хаотично, пробуем нестандартные действия.</p>
<p>5.Переход к структуре: smoke, регресс и re-test</p>
<p>Выделяем минимум проверок, которые всегда должны проходить — это smoke-тестирование. Проверка базовой работоспособности.
При тестировании функционала или smoke-набора могут обнаружиться дефекты. В таком случае заводится баг-репорт, а после его исправления проводится ретест — точечная проверка, что конкретный баг действительно устранён. Только баг, только конкретный сценарий. Без расширений и дополнительных проверок.
А для полной уверенности запускаем регрессионное тестирование. Это все ключевые сценарии, которые не должны ломаться от изменений. Мы постепенно переходим от хаотичного к системному подходу.</p>
<p>6.Ящики: чёрный, белый, серый</p>
<p>Если мы не смотрим в код — это чёрный ящик. Просто ввод-вывод. Если имеем доступ и понимаем внутреннюю логику — белый ящик. Если доступ есть частично или мы комбинируем подходы — серый ящик. Применимо в любой момент проекта.</p>
<p>7.Архитектура и модули</p>
 <p>Здесь пригодится интеграционное тестирование: как наши модули взаимодействуют между собой.
Когда два модуля объединены, можно говорить уже о системном тестировании — мы проверяем работу всей системы целиком. А когда демонстрируем результат заказчику, показываем, реализовано ли то, что он ожидал — это уже приёмочное тестирование.</p>
<p>8.Ручное и автоматизированное тестирование</p>
<p>9.Нагрузочное и безопасность</p>
<p>- Тестирование производительности — справляется ли система с нужной скоростью.
- Стрессовое тестирование — что будет, если нагрузка превысит ожидаемую.
  По части защиты — тестирование безопасности. В нашем случае используются базовые защиты: HTTPS, ограничение прав, защита от SQL-инъекций.</p>
<p>10.Объём, анализ и выводы</p>
<p>Когда MVP создан — начинается анализ. Проводятся A/B тесты, собирается статистика, бизнес оценивает востребованность приложения.</p>
<p>11.Финальный аккорд</p>

</details>









